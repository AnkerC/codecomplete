
## 
1. epoll,select原理和优缺点

select 缺点：
1. 监听的文件描述符受FD_SIZE大小限制
2. 每次被唤醒需要遍历才知道那个FD ready，描述符越多越慢
3. 描述符需要从内核态copy到用户态


epoll优点：
1. 没有监听FD_SIZE的限制，只受文件描述符限制,ulimit -n设置，运维一般设置为20W
2. 每次唤醒是所有ready的FD，还有类型
3. 内核态和用户态共享内存，无copy

epoll编程：
epoll_create->epoll_ctl注册描述符->epoll_wait阻塞等待内核通知

水平触发(默认是水平触发)
    读：数据可读或者数据没读完，就会不停的向上层触发可读的事件
    写: 
边缘触发
    读：数据可读后只触发一次，如果上层没一次读完，也不会再通知了。所以上层要一次全读完
    写：


2. O_DIRECT,O_SYNC 标记的写行为








3. 孤儿进程，僵尸进程，父子进程







4. Linux进程调度









5. 多线程编程






6. 进程间通信的方法和各自适应的场景
unix socket：
1.

共享内存：
1.无消息的拷贝
2.对共享的资源可能需要加锁

信号：


socket：

管道：
    用于父子进程通信




7. socket编程模型
分为客户端和服务端。
客户端：
    connect：内核查路由，路由可达后发送SYN，阻塞模式下等待，收到服务端的SYN+ACK，函数返回，TCP三次握手连接建立。如果SYN超时，错误码对应超时。
    read/write: 通过TCP发送和接收报文的过程。
    close: 向服务端发送FIN，如果服务端没有回ACK或者ACK网络丢包，对应上层行为？

服务端：
    bind:

    listen:

    accept:

    close:

    








8. numa的理解





9. 内存模型
内存分为5个区
代码区：

全局静态区

堆：

栈：









